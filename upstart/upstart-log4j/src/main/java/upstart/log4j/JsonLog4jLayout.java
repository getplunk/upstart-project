package upstart.log4j;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.CharStreams;
import upstart.config.ObjectMapperFactory;
import upstart.config.UpstartEnvironment;
import upstart.log.UpstartLogConfig;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ThrowableInformation;
import org.immutables.value.Value;

import java.io.IOException;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.Optional;

public class JsonLog4jLayout extends Layout {
  private static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ISO_INSTANT;

  private final ObjectMapper objectMapper;
  private final Optional<Map<String, Object>> context;

  public JsonLog4jLayout(ObjectMapper objectMapper, UpstartLogConfig config) {
    this.objectMapper = objectMapper.copy().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
    this.context = Optional.of(config.context()).filter(m -> !m.isEmpty());
  }

  /**
   * no-arg constructor to allow this layout to be used directly from log4j.properties
   * @deprecated prefer {@link #JsonLog4jLayout(ObjectMapper,UpstartLogConfig)}
   */
  @Deprecated
  public JsonLog4jLayout() {
    this(ObjectMapperFactory.buildAmbientObjectMapper(), UpstartEnvironment.loadAmbientConfigValue(UpstartLogConfig.class));
  }

  @Override
  public String format(LoggingEvent event) {
    LoggingEventJson json = LoggingEventJson.of(event, context);
    try {
      return serialize(json);
    } catch (Exception e) {
      LogLog.error("Unable to serialize LoggingEvent: " + event.getRenderedMessage(), e);
      try {
        // assume the exception resulted from trying to serialize the payload
        return serialize(json.applyPayloadException(e));
      } catch (Exception ex) {
        // emit *something* to reflect that there's a problem
        // TODO: could use some other mechanism to try to emit LoggingEvent data, but need correct json-formatting
        return "{\"logError\":\"" + ex.getClass().getName() + "\"}" + Layout.LINE_SEP;
      }
    }
  }

  public String serialize(LoggingEventJson event) throws IOException {
    StringBuilder builder = new StringBuilder();
    objectMapper.writeValue(CharStreams.asWriter(builder), event);
    return builder.append(Layout.LINE_SEP).toString();
  }

  @Override
  public boolean ignoresThrowable() {
    return false;
  }

  @Override
  public void activateOptions() {
  }

  /** for some hope of consistency, this structure is designed to mimic the data generated by the logstash json-formatter,
   *  with extra fields added for custom payload
   */
  @Value.Immutable
  @JsonSerialize
  interface LoggingEventJson {

    @JsonProperty("@timestamp")
    String timestamp();
    String level();
    String message();
    Optional<Object> payload();
    Optional<ThrowableInfoJson> payload_exception();

    @Value.Default
    default Optional<Class<?>> payload_type() { return payload().map(Object::getClass); }

    String logger_name();

    @JsonIgnore
    Optional<Map<String, Object>> context();

    @JsonAnyGetter
    default Map<String, Object> getContext() {
      return context().orElse(ImmutableMap.of());
    }

    Optional<ThrowableInfoJson> exception();
    String thread_name();

    @JsonProperty("@version")
    default int version() {
      return 1;
    }

    static LoggingEventJson of(LoggingEvent event, Optional<Map<String, Object>> context) {
      return ImmutableLoggingEventJson.builder()
              .timestamp(TIMESTAMP_FORMATTER.format(Instant.ofEpochMilli(event.getTimeStamp())))
              .level(event.getLevel().toString())
              .message(event.getRenderedMessage())
              .payload(Optional.ofNullable(event.getMDC(UpstartLog4jProvider.STRUCTURED_LOG_PAYLOAD)))
              .logger_name(event.getLoggerName())
              .context(context)
              .exception(Optional.ofNullable(event.getThrowableInformation()).map(ThrowableInfoJson::from))
              .thread_name(event.getThreadName())
              .build();
    }

    default LoggingEventJson applyPayloadException(Throwable e) {
      return ImmutableLoggingEventJson.builder()
              .from(this)
              .payload(Optional.empty())
              .payload_exception(ThrowableInfoJson.from(e))
              .build();
    }

    @Value.Immutable
    @JsonSerialize
    interface ThrowableInfoJson {

      Optional<Class<? extends Throwable>> exception_class();
      Optional<String> exception_message();
      Optional<String> stacktrace();

      ThrowableInfoJson MISSING = ImmutableThrowableInfoJson.builder().exception_message("[exception missing]").build();

      static ThrowableInfoJson from(Throwable throwable) {
        return ImmutableThrowableInfoJson.builder()
                .exception_class(throwable.getClass())
                .exception_message(Optional.ofNullable(throwable.getMessage()))
                .stacktrace(Throwables.getStackTraceAsString(throwable))
                .build();
      }

      static ThrowableInfoJson from(ThrowableInformation info) {
        Throwable throwable = info.getThrowable();
        if (throwable != null) return from(throwable);
        return Optional.ofNullable(info.getThrowableStrRep())
                .<ThrowableInfoJson>map(strRep -> ImmutableThrowableInfoJson.builder()
                        .stacktrace(String.join("\n", strRep))
                        .build()
                ).orElse(MISSING); // shouldn't happen?
      }
    }
  }
}
